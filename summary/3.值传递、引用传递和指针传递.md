---
sort: 3
---
# 值传递、引用传递和指针传递

## 值传递：

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，

不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

## 指针传递：

形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作

## 引用传递：

形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

## 总结

- 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
- 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
- 而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
  
## 示例


```cpp


#include<iostream>

using namespace std;

//值传递
void passByValue(int n)
{
    cout<<"值传递--函数操作地址"<<&n<<endl;         //显示的是拷贝的地址而不是源地址
    n++;
}

//引用传递
void passByReference(int & n)
{
    cout << "引用传递--函数操作地址" << &n << endl;
    n++;
}

 //指针传递
 void passByPoint(int *n)
 {
          cout<<"指针传递--函数操作地址 "<<n<<endl;
         *n=*n+1;
 }

 int  main()
 {
    int n=10;
    cout<<"实参的地址"<<&n<<endl;
    passByValue(n);
    cout<<"after passByValue() n="<<n<<endl;
    passByReference(n);
    cout<<"after passByReference() n="<<n<<endl;
    passByPoint(&n);
    cout<<"after passByPoint() n="<<n<<endl;
    return true;
}
```

## 运行结果

```cpp
实参的地址`0x61fe1c`
值传递--函数操作地址 0x61fdf0
after passByValue() n=10
引用传递--函数操作地址 0x61fe1c
after passByReference() n=11
指针传递--函数操作地址 0x61fe1c
after passByPoint() n=12
```

## 结果分析

- 值传递:函数操作的地址是`0x61fdf0`并不是实参本身，所以对它进行操作并不能改变实参的值;
- 引用传递:操作地址就是实参地址，只是相当于实参的一个别名，对它的操作就是对实参的操作;
- 指针传递:操作地址是实参地址

## 引用传递和指针传递的区别

###  引用规则： 
- 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 
- 不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 
- 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
  
### 指针传递的本质

指针传递参数本质上是值传递的方式，它所传递的是一个地址值。

值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）

### 指针传递和引用传递的适用范围

函数内部修改参数并且希望改动影响调用者。对比指针/引用传递可以将改变由形参“传给”实参（实际上就是直接在实参的内存上修改，不像值传递将实参的值拷贝到另外的内存地址中才修改）。

另外一种用法是：当一个函数实际需要返回多个值，而只能显式返回一个值时，可以将另外需要返回的变量以指针/引用传递给函数，这样在函数内部修改并且返回后，调用者可以拿到被修改过后的变量，也相当于一个隐式的返回值传递吧。



