---
sort: 1
---
# 初始化链表

## 问题
问题已知链表节点定义如下：

```
class ListNode {
public:
    int val;
    ListNode* next;
public:
    ListNode(int v, ListNode* n = NULL): val(v), next(n) {}
};
```

如何用 C++ 初始化出指定链表，如：1->2->3？

## 一般做法

1. 直接法，这种方法遇到长的链表会导致一行长度过长：

```
ListNode* list = new ListNode(1, new ListNode(2, new ListNode(3)));
```

2. 分步法，缩短列宽，缺点是初始化长度为 n 的链表需要 n 行代码：

```
ListNode* list = new ListNode(1);
ListNode* node2 = list->next = new ListNode(2);
node2->next = new ListNode(3);
```

3. 循环法，常用做法

```
int values[] = {1, 2, 3};
ListNode* list = new ListNode(values[0]);
ListNode* cur = list;
for (int i = 1; i < 3; ++i) {
    cur->next = new ListNode(values[i]);
    cur = cur->next;
}
```
可以看出，这 3 种方法都比较啰嗦，如果使用 C++11 的列表初始化，可以简化很多。

## 列表list初始化

![20220109130336-2022-01-09-13-03-37](https://raw.githubusercontent.com/ironartisan/picRepo/main/20220109130336-2022-01-09-13-03-37.png)

## 初始化链表

如何利用列表初始化语法初始化链表呢？

```
ListNode* list {1, new ListNode {2, new ListNode {3}}};
```

但是这样，跟上面的方法 1 几乎是一样的，初始化语句中有许多冗余的 new ListNode。

如何去掉 new ListNode 呢？

可以使用一个辅助类 ListBuilder 把 new ListNode “包”起来：

```
struct ListBuilder {
    int v;
    ListNode* p;
      (ListNode* p = nullptr): p(p) {}
    ListBuilder(int d, ListBuilder b = ListBuilder())
        : p(new ListNode(d, b.p)) {}
    operator ListNode* () const {
        return p;
    }
};
```

用法是这样：

```
ListNode* list = ListBuilder {1, {2, {3}}};
```

当编译器遇到 `ListBuilder {1, {2, {3}}}` 时，认识到这是一个列表初始化，
会在 `ListBuilder` 的构造函数中寻找匹配函数签名(int, ...)的函数。

`ListBuilder(int d, ListBuilder b = ListBuilder())` 被匹配到。

`{1, {2, {3}}}`中的 `1` 被用于初始化参数 `d,{2, {3}}` 被用于初始化参数 `b`。

因为 `b` 也是 `ListBuilder` ，上述过程会递归地进行下去，直到遇到 `{3}`，递归终止。

最后，`ListBuilder {1, {2, {3}}}` 初始化完成，得到一个 `ListBuilder` 实例，将它赋值给 `ListNode* list`。

为了实现从 `ListBuilder` 到 `ListNode` 的转换，需要类型操作符重载：

```
operator ListNode* () const {
    return p;
}
```

## 参考资料
[使用列表初始化语法初始化链表](https://zlsun.github.io/2016/04/07/use-list-initialzation-to-initial-linklist/)